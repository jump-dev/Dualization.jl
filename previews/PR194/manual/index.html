<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Dualization.jl</title><meta name="title" content="Manual · Dualization.jl"/><meta property="og:title" content="Manual · Dualization.jl"/><meta property="twitter:title" content="Manual · Dualization.jl"/><meta name="description" content="Documentation for Dualization.jl."/><meta property="og:description" content="Documentation for Dualization.jl."/><meta property="twitter:description" content="Documentation for Dualization.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Dualization.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dualization.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Dualize-a-JuMP-model"><span>Dualize a JuMP model</span></a></li><li><a class="tocitem" href="#Name-the-dual-variables-and-dual-constraints"><span>Name the dual variables and dual constraints</span></a></li><li><a class="tocitem" href="#Pass-a-new-optimizer"><span>Pass a new optimizer</span></a></li><li><a class="tocitem" href="#Solve-a-problem-using-its-dual-formulation"><span>Solve a problem using its dual formulation</span></a></li><li><a class="tocitem" href="#The-benefit-of-solving-the-dual-formulation"><span>The benefit of solving the dual formulation</span></a></li><li><a class="tocitem" href="#Supported-problem-types"><span>Supported problem types</span></a></li><li><a class="tocitem" href="#Advanced:-add-support-for-new-sets"><span>Advanced: add support for new sets</span></a></li></ul></li><li><a class="tocitem" href="../mathematical_background/">Mathematical background</a></li><li><a class="tocitem" href="../reference/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/Dualization.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/Dualization.jl/blob/master/docs/src/manual.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><h2 id="Dualize-a-JuMP-model"><a class="docs-heading-anchor" href="#Dualize-a-JuMP-model">Dualize a JuMP model</a><a id="Dualize-a-JuMP-model-1"></a><a class="docs-heading-anchor-permalink" href="#Dualize-a-JuMP-model" title="Permalink"></a></h2><p>Use <a href="../reference/#dualize"><code>dualize</code></a> to formulate the dual of a JuMP model.</p><p>For example, consider this problem:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP, Dualization</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; begin
           model = Model()
           @variable(model, x)
           @variable(model, y &gt;= 0)
           @variable(model, z)
           @constraint(model, soccon, [1.0 * x + 2.0, y, z] in SecondOrderCone())
           @constraint(model, eqcon, x == 1)
           @constraint(model, con_le, x + y &gt;= 1)
           @objective(model, Min, y + z)
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(model)</code><code class="nohighlight hljs ansi" style="display:block;">Min y + z
Subject to
 eqcon : x = 1
 con_le : x + y ≥ 1
 soccon : [x + 2, y, z] ∈ MathOptInterface.SecondOrderCone(3)
 y ≥ 0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual_model = dualize(model)</code><code class="nohighlight hljs ansi" style="display:block;">A JuMP Model
├ solver: none
├ objective_sense: MAX_SENSE
│ └ objective_function_type: JuMP.AffExpr
├ num_variables: 5
├ num_constraints: 5
│ ├ JuMP.AffExpr in MOI.EqualTo{Float64}: 2
│ ├ JuMP.AffExpr in MOI.GreaterThan{Float64}: 1
│ ├ Vector{JuMP.VariableRef} in MOI.SecondOrderCone: 1
│ └ JuMP.VariableRef in MOI.GreaterThan{Float64}: 1
└ Names registered in the model: none</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(dual_model)</code><code class="nohighlight hljs ansi" style="display:block;">Max _[2] - 2 _[3] + _[1]
Subject to
 _[1] + _[2] + _[3] = 0
 _[5] = 1
 -_[2] - _[4] ≥ -1
 [_[3], _[4], _[5]] ∈ MathOptInterface.SecondOrderCone(3)
 _[2] ≥ 0</code></pre><h2 id="Name-the-dual-variables-and-dual-constraints"><a class="docs-heading-anchor" href="#Name-the-dual-variables-and-dual-constraints">Name the dual variables and dual constraints</a><a id="Name-the-dual-variables-and-dual-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Name-the-dual-variables-and-dual-constraints" title="Permalink"></a></h2><p>Provide prefixes for the names of the variables and constraints using <a href="../reference/#DualNames"><code>DualNames</code></a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual_model = dualize(model; dual_names = DualNames(&quot;dual_var_&quot;, &quot;dual_con_&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">A JuMP Model
├ solver: none
├ objective_sense: MAX_SENSE
│ └ objective_function_type: JuMP.AffExpr
├ num_variables: 5
├ num_constraints: 5
│ ├ JuMP.AffExpr in MOI.EqualTo{Float64}: 2
│ ├ JuMP.AffExpr in MOI.GreaterThan{Float64}: 1
│ ├ Vector{JuMP.VariableRef} in MOI.SecondOrderCone: 1
│ └ JuMP.VariableRef in MOI.GreaterThan{Float64}: 1
└ Names registered in the model
  └ :dual_con_x, :dual_con_y, :dual_con_z, :dual_var_con_le, :dual_var_eqcon, :dual_var_soccon_1, :dual_var_soccon_2, :dual_var_soccon_3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(dual_model)</code><code class="nohighlight hljs ansi" style="display:block;">Max dual_var_con_le - 2 dual_var_soccon_1 + dual_var_eqcon
Subject to
 dual_con_x : dual_var_eqcon + dual_var_con_le + dual_var_soccon_1 = 0
 dual_con_z : dual_var_soccon_3 = 1
 dual_con_y : -dual_var_con_le - dual_var_soccon_2 ≥ -1
 [dual_var_soccon_1, dual_var_soccon_2, dual_var_soccon_3] ∈ MathOptInterface.SecondOrderCone(3)
 dual_var_con_le ≥ 0</code></pre><h2 id="Pass-a-new-optimizer"><a class="docs-heading-anchor" href="#Pass-a-new-optimizer">Pass a new optimizer</a><a id="Pass-a-new-optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Pass-a-new-optimizer" title="Permalink"></a></h2><p>If the primal model has an optimizer attached you will lose the optimizer during the dualization. To dualize the model and attach the optimizer to the dual model you should do <code>dualize(model, optimizer)</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import ECOS</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual_model = dualize(model, ECOS.Optimizer)</code><code class="nohighlight hljs ansi" style="display:block;">A JuMP Model
├ solver: ECOS
├ objective_sense: MAX_SENSE
│ └ objective_function_type: JuMP.AffExpr
├ num_variables: 5
├ num_constraints: 5
│ ├ JuMP.AffExpr in MOI.EqualTo{Float64}: 2
│ ├ JuMP.AffExpr in MOI.GreaterThan{Float64}: 1
│ ├ Vector{JuMP.VariableRef} in MOI.SecondOrderCone: 1
│ └ JuMP.VariableRef in MOI.GreaterThan{Float64}: 1
└ Names registered in the model: none</code></pre><h2 id="Solve-a-problem-using-its-dual-formulation"><a class="docs-heading-anchor" href="#Solve-a-problem-using-its-dual-formulation">Solve a problem using its dual formulation</a><a id="Solve-a-problem-using-its-dual-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-a-problem-using-its-dual-formulation" title="Permalink"></a></h2><p>Wrap an optimizer with <a href="../reference/#dual_optimizer"><code>dual_optimizer</code></a> to solve the dual of the problem instead of the primal:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP, Dualization, ECOS</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model(dual_optimizer(ECOS.Optimizer))</code><code class="nohighlight hljs ansi" style="display:block;">A JuMP Model
├ solver: Dual model with ECOS attached
├ objective_sense: FEASIBILITY_SENSE
├ num_variables: 0
├ num_constraints: 0
└ Names registered in the model: none</code></pre><p>You can also set the optimizer after the model is created:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP, Dualization, ECOS</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model()</code><code class="nohighlight hljs ansi" style="display:block;">A JuMP Model
├ solver: none
├ objective_sense: FEASIBILITY_SENSE
├ num_variables: 0
├ num_constraints: 0
└ Names registered in the model: none</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; set_optimizer(model, dual_optimizer(ECOS.Optimizer))</code></pre><p>Pass arguments to the solver by attaching them to the solver constructor:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP, Dualization, ECOS</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model(dual_optimizer(optimizer_with_attributes(ECOS.Optimizer, &quot;maxit&quot; =&gt; 5)))</code><code class="nohighlight hljs ansi" style="display:block;">A JuMP Model
├ solver: Dual model with ECOS attached
├ objective_sense: FEASIBILITY_SENSE
├ num_variables: 0
├ num_constraints: 0
└ Names registered in the model: none</code></pre><p>or by using <code>JuMP.set_attribute</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP, Dualization, ECOS</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model(dual_optimizer(ECOS.Optimizer))</code><code class="nohighlight hljs ansi" style="display:block;">A JuMP Model
├ solver: Dual model with ECOS attached
├ objective_sense: FEASIBILITY_SENSE
├ num_variables: 0
├ num_constraints: 0
└ Names registered in the model: none</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; set_attribute(model, &quot;maxit&quot;, 5)</code></pre><h2 id="The-benefit-of-solving-the-dual-formulation"><a class="docs-heading-anchor" href="#The-benefit-of-solving-the-dual-formulation">The benefit of solving the dual formulation</a><a id="The-benefit-of-solving-the-dual-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#The-benefit-of-solving-the-dual-formulation" title="Permalink"></a></h2><p>Solving an optimization problem via its dual representation can be useful because some conic solvers assume the model is in the standard form and others use the geometric form.</p><p>The geometric conic form has affine expressions in cones:</p><p class="math-container">\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; c^T x
\\
&amp; \;\;\text{s.t.} &amp; A_i x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align}\]</p><p>The standard form has variables in cones:</p><p class="math-container">\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; c^T x
\\
&amp; \;\;\text{s.t.} &amp; A x + s &amp; = b
\\
&amp; &amp; s &amp; \in \mathcal{C}
\end{align}\]</p><p>Solvers which use the geometric conic form include CDCS, SCS, ECOS, and SeDuMi. Solvers which use the standard conic form include SDPT3, SDPNAL, CSDP, and SDPA. Mosek v10 supports both affine constraints in cones and variables in cones, hence both the standard and geometric form at the same time.</p><h2 id="Supported-problem-types"><a class="docs-heading-anchor" href="#Supported-problem-types">Supported problem types</a><a id="Supported-problem-types-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-problem-types" title="Permalink"></a></h2><p>Dualization.jl works only for optimization models that can be written in conic form, and that are composed of the following constraints and objectives.</p><p>If you try to dualize an unsupported model, and error will be thrown.</p><h3 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h3><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Set</th></tr><tr><td style="text-align: left"><code>MOI.VariableIndex</code> or <code>MOI.ScalarAffineFunction</code></td><td style="text-align: left"><code>MOI.GreaterThan</code></td></tr><tr><td style="text-align: left"><code>MOI.VariableIndex</code> or <code>MOI.ScalarAffineFunction</code></td><td style="text-align: left"><code>MOI.LessThan</code></td></tr><tr><td style="text-align: left"><code>MOI.VariableIndex</code> or <code>MOI.ScalarAffineFunction</code></td><td style="text-align: left"><code>MOI.EqualTo</code></td></tr><tr><td style="text-align: left"><code>MOI.VectorOfVariables</code> or <code>MOI.VectorAffineFunction</code></td><td style="text-align: left"><code>MOI.Nonnegatives</code></td></tr><tr><td style="text-align: left"><code>MOI.VectorOfVariables</code> or <code>MOI.VectorAffineFunction</code></td><td style="text-align: left"><code>MOI.Nonpositives</code></td></tr><tr><td style="text-align: left"><code>MOI.VectorOfVariables</code> or <code>MOI.VectorAffineFunction</code></td><td style="text-align: left"><code>MOI.Zeros</code></td></tr><tr><td style="text-align: left"><code>MOI.VectorOfVariables</code> or <code>MOI.VectorAffineFunction</code></td><td style="text-align: left"><code>MOI.SecondOrderCone</code></td></tr><tr><td style="text-align: left"><code>MOI.VectorOfVariables</code> or <code>MOI.VectorAffineFunction</code></td><td style="text-align: left"><code>MOI.RotatedSecondOrderCone</code></td></tr><tr><td style="text-align: left"><code>MOI.VectorOfVariables</code> or <code>MOI.VectorAffineFunction</code></td><td style="text-align: left"><code>MOI.PositiveSemidefiniteConeTriangle</code></td></tr><tr><td style="text-align: left"><code>MOI.VectorOfVariables</code> or <code>MOI.VectorAffineFunction</code></td><td style="text-align: left"><code>MOI.ExponentialCone</code></td></tr><tr><td style="text-align: left"><code>MOI.VectorOfVariables</code> or <code>MOI.VectorAffineFunction</code></td><td style="text-align: left"><code>MOI.DualExponentialCone</code></td></tr><tr><td style="text-align: left"><code>MOI.VectorOfVariables</code> or <code>MOI.VectorAffineFunction</code></td><td style="text-align: left"><code>MOI.PowerCone</code></td></tr><tr><td style="text-align: left"><code>MOI.VectorOfVariables</code> or <code>MOI.VectorAffineFunction</code></td><td style="text-align: left"><code>MOI.DualPowerCone</code></td></tr></table><p>Note that some of MOI constraints can be bridged, see <a href="http://jump.dev/MathOptInterface.jl/stable/apireference/#Bridges-1">Bridges</a>, to constraints in this list.</p><h3 id="Objective-functions"><a class="docs-heading-anchor" href="#Objective-functions">Objective functions</a><a id="Objective-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-functions" title="Permalink"></a></h3><table><tr><th style="text-align: left">Function</th></tr><tr><td style="text-align: left"><code>MOI.VariableIndex</code></td></tr><tr><td style="text-align: left"><code>MOI.ScalarAffineFunction</code></td></tr><tr><td style="text-align: left"><code>MOI.ScalarQuadraticFunction</code></td></tr></table><h2 id="Advanced:-add-support-for-new-sets"><a class="docs-heading-anchor" href="#Advanced:-add-support-for-new-sets">Advanced: add support for new sets</a><a id="Advanced:-add-support-for-new-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-add-support-for-new-sets" title="Permalink"></a></h2><p>Dualization.jl can automatically dualize models with custom sets.</p><p>To do this, the user needs to define the set and its dual set and provide the functions:</p><ul><li><a href="../reference/#Dualization.supported_constraint"><code>Dualization.supported_constraint</code></a></li><li><code>MathOptInterface.dual_set</code></li></ul><p>If the custom set has some special scalar product (see the <a href="https://jump.dev/MathOptInterface.jl/stable/apireference/#MathOptInterface.AbstractSymmetricMatrixSetTriangle">link</a>), the user also needs to provide the <code>MathOptInterface.Utilities.set_dot</code> function.</p><p>For example, let us define a fake cone and its dual, the fake dual cone. We will write a JuMP model with the fake cone and dualize it.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Dualization, JuMP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct FakeCone &lt;: MOI.AbstractVectorSet
           dimension::Int
       end</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct FakeDualCone &lt;: MOI.AbstractVectorSet
           dimension::Int
       end</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, x[1:3] &gt;= 0)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{JuMP.VariableRef}:
 x[1]
 x[2]
 x[3]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @constraint(model, con, 1.0 * x in FakeCone(3))</code><code class="nohighlight hljs ansi" style="display:block;">con : [x[1], x[2], x[3]] ∈ Main.FakeCone(3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @objective(model, Min, sum(x))</code><code class="nohighlight hljs ansi" style="display:block;">x[1] + x[2] + x[3]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(model)</code><code class="nohighlight hljs ansi" style="display:block;">Min x[1] + x[2] + x[3]
Subject to
 x[1] ≥ 0
 x[2] ≥ 0
 x[3] ≥ 0
 con : [x[1], x[2], x[3]] ∈ Main.FakeCone(3)</code></pre><p>Now in order to dualize we must overload the methods as described above.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; MOI.dual_set(s::FakeCone) = FakeDualCone(MOI.dimension(s))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function Dualization.supported_constraint(
           ::Type{MOI.VectorOfVariables},
           ::Type{FakeCone},
       )
           return true
       end</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function Dualization.supported_constraint(
           ::Type{&lt;:MOI.VectorAffineFunction},
           ::Type{FakeCone},
       )
           return true
       end</code></pre><p>If your set has some specific scalar product you also need to define a new <code>set_dot</code> function. Assume that our FakeCone has this weird scalar product:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import LinearAlgebra</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function MOI.Utilities.set_dot(x::Vector, y::Vector, ::FakeCone)
           return 2 * LinearAlgebra.dot(x, y)
       end</code></pre><p>Dualize the model</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual_model = dualize(model)</code><code class="nohighlight hljs ansi" style="display:block;">A JuMP Model
├ solver: none
├ objective_sense: MAX_SENSE
│ └ objective_function_type: JuMP.AffExpr
├ num_variables: 3
├ num_constraints: 4
│ ├ JuMP.AffExpr in MOI.GreaterThan{Float64}: 3
│ └ Vector{JuMP.VariableRef} in Main.FakeDualCone: 1
└ Names registered in the model: none</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(dual_model)</code><code class="nohighlight hljs ansi" style="display:block;">Max 0
Subject to
 -_[1] ≥ -1
 -_[2] ≥ -1
 -_[3] ≥ -1
 [_[1], _[2], _[3]] ∈ Main.FakeDualCone(3)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../mathematical_background/">Mathematical background »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 3 June 2025 03:57">Tuesday 3 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
